{"mappings":"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","sources":["<anon>","node_modules/.pnpm/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemFileHandle.js"],"sourcesContent":["\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"ggMY5\", function(module, exports) {\n\n$parcel$defineInteropFlag(module.exports);\n\n$parcel$export(module.exports, \"FileSystemFileHandle\", () => $bd841fffd4068e5b$export$db2751aad7d8e0f3);\n$parcel$export(module.exports, \"default\", () => $bd841fffd4068e5b$export$2e2bcd8739ae039);\n\nvar $bAgeV = parcelRequire(\"bAgeV\");\n\nvar $gnYLk = parcelRequire(\"gnYLk\");\n\nvar $jG9Jm = parcelRequire(\"jG9Jm\");\nconst { INVALID: $bd841fffd4068e5b$var$INVALID, SYNTAX: $bd841fffd4068e5b$var$SYNTAX, GONE: $bd841fffd4068e5b$var$GONE } = (0, $jG9Jm.errors);\nconst $bd841fffd4068e5b$var$kAdapter = Symbol('adapter');\nclass $bd841fffd4068e5b$export$db2751aad7d8e0f3 extends (0, $bAgeV.default) {\n    /** @type {FileSystemFileHandle} */ [$bd841fffd4068e5b$var$kAdapter];\n    constructor(adapter){\n        super(adapter);\n        this[$bd841fffd4068e5b$var$kAdapter] = adapter;\n    }\n    /**\n   * @param  {Object} [options={}]\n   * @param  {boolean} [options.keepExistingData]\n   * @returns {Promise<FileSystemWritableFileStream>}\n   */ async createWritable(options = {}) {\n        return new (0, $gnYLk.default)(await this[$bd841fffd4068e5b$var$kAdapter].createWritable(options));\n    }\n    /**\n   * @returns {Promise<File>}\n   */ async getFile() {\n        return this[$bd841fffd4068e5b$var$kAdapter].getFile();\n    }\n}\nObject.defineProperty($bd841fffd4068e5b$export$db2751aad7d8e0f3.prototype, Symbol.toStringTag, {\n    value: 'FileSystemFileHandle',\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties($bd841fffd4068e5b$export$db2751aad7d8e0f3.prototype, {\n    createWritable: {\n        enumerable: true\n    },\n    getFile: {\n        enumerable: true\n    }\n});\n// Safari doesn't support async createWritable streams yet.\nif (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable) {\n    const wm = new WeakMap();\n    let workerUrl;\n    // Worker code that should be inlined (can't use any external functions)\n    const code = ()=>{\n        let fileHandle, handle;\n        onmessage = async (evt)=>{\n            const port = evt.ports[0];\n            const cmd = evt.data;\n            switch(cmd.type){\n                case 'open':\n                    const file = cmd.name;\n                    let dir = await navigator.storage.getDirectory();\n                    for (const folder of cmd.path)dir = await dir.getDirectoryHandle(folder);\n                    fileHandle = await dir.getFileHandle(file);\n                    handle = await fileHandle.createSyncAccessHandle();\n                    break;\n                case 'write':\n                    handle.write(cmd.data, {\n                        at: cmd.position\n                    });\n                    handle.flush();\n                    break;\n                case 'truncate':\n                    handle.truncate(cmd.size);\n                    break;\n                case 'abort':\n                case 'close':\n                    handle.close();\n                    break;\n            }\n            port.postMessage(0);\n        };\n    };\n    globalThis.FileSystemFileHandle.prototype.createWritable = async function(options) {\n        // Safari only support writing data in a worker with sync access handle.\n        if (!workerUrl) {\n            const stringCode = `(${code.toString()})()`;\n            const blob = new Blob([\n                stringCode\n            ], {\n                type: 'text/javascript'\n            });\n            workerUrl = URL.createObjectURL(blob);\n        }\n        const worker = new Worker(workerUrl, {\n            type: 'module'\n        });\n        let position = 0;\n        const textEncoder = new TextEncoder();\n        let size = await this.getFile().then((file)=>file.size);\n        const send = (message)=>new Promise((resolve, reject)=>{\n                const mc = new MessageChannel();\n                mc.port1.onmessage = (evt)=>{\n                    if (evt.data instanceof Error) reject(evt.data);\n                    else resolve(evt.data);\n                    mc.port1.close();\n                    mc.port2.close();\n                    mc.port1.onmessage = null;\n                };\n                worker.postMessage(message, [\n                    mc.port2\n                ]);\n            });\n        // Safari also don't support transferable file system handles.\n        // So we need to pass the path to the worker. This is a bit hacky and ugly.\n        const root = await navigator.storage.getDirectory();\n        const parent = await wm.get(this);\n        const path = await root.resolve(parent);\n        // Should likely never happen, but just in case...\n        if (path === null) throw new DOMException(...$bd841fffd4068e5b$var$GONE);\n        let controller;\n        await send({\n            type: 'open',\n            path: path,\n            name: this.name\n        });\n        if (options?.keepExistingData === false) {\n            await send({\n                type: 'truncate',\n                size: 0\n            });\n            size = 0;\n        }\n        const ws = new (0, $gnYLk.default)({\n            start: (ctrl)=>{\n                controller = ctrl;\n            },\n            async write (chunk) {\n                const isPlainObject = chunk?.constructor === Object;\n                if (isPlainObject) chunk = {\n                    ...chunk\n                };\n                else chunk = {\n                    type: 'write',\n                    data: chunk,\n                    position: position\n                };\n                if (chunk.type === 'write') {\n                    if (!('data' in chunk)) {\n                        await send({\n                            type: 'close'\n                        });\n                        throw new DOMException(...$bd841fffd4068e5b$var$SYNTAX('write requires a data argument'));\n                    }\n                    chunk.position ??= position;\n                    if (typeof chunk.data === 'string') chunk.data = textEncoder.encode(chunk.data);\n                    else if (chunk.data instanceof ArrayBuffer) chunk.data = new Uint8Array(chunk.data);\n                    else if (!(chunk.data instanceof Uint8Array) && ArrayBuffer.isView(chunk.data)) chunk.data = new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.data.byteLength);\n                    else if (!(chunk.data instanceof Uint8Array)) {\n                        const ab = await new Response(chunk.data).arrayBuffer();\n                        chunk.data = new Uint8Array(ab);\n                    }\n                    if (Number.isInteger(chunk.position) && chunk.position >= 0) position = chunk.position;\n                    position += chunk.data.byteLength;\n                    size += chunk.data.byteLength;\n                } else if (chunk.type === 'seek') {\n                    if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n                        if (size < chunk.position) throw new DOMException(...$bd841fffd4068e5b$var$INVALID);\n                        console.log('seeking', chunk);\n                        position = chunk.position;\n                        return; // Don't need to enqueue seek...\n                    } else {\n                        await send({\n                            type: 'close'\n                        });\n                        throw new DOMException(...$bd841fffd4068e5b$var$SYNTAX('seek requires a position argument'));\n                    }\n                } else if (chunk.type === 'truncate') {\n                    if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n                        size = chunk.size;\n                        if (position > size) position = size;\n                    } else {\n                        await send({\n                            type: 'close'\n                        });\n                        throw new DOMException(...$bd841fffd4068e5b$var$SYNTAX('truncate requires a size argument'));\n                    }\n                }\n                await send(chunk);\n            },\n            async close () {\n                await send({\n                    type: 'close'\n                });\n                worker.terminate();\n            },\n            async abort (reason) {\n                await send({\n                    type: 'abort',\n                    reason: reason\n                });\n                worker.terminate();\n            }\n        });\n        return ws;\n    };\n    const orig = FileSystemDirectoryHandle.prototype.getFileHandle;\n    FileSystemDirectoryHandle.prototype.getFileHandle = async function(...args) {\n        const handle = await orig.call(this, ...args);\n        wm.set(handle, this);\n        return handle;\n    };\n}\nvar $bd841fffd4068e5b$export$2e2bcd8739ae039 = $bd841fffd4068e5b$export$db2751aad7d8e0f3;\n\n});\n\n\n//# sourceMappingURL=FileSystemFileHandle.f331cfd5.js.map\n","import FileSystemHandle from './FileSystemHandle.js'\nimport FileSystemWritableFileStream from './FileSystemWritableFileStream.js'\nimport { errors } from './util.js'\n\nconst { INVALID, SYNTAX, GONE } = errors\n\nconst kAdapter = Symbol('adapter')\n\nclass FileSystemFileHandle extends FileSystemHandle {\n  /** @type {FileSystemFileHandle} */\n  [kAdapter]\n\n  constructor (adapter) {\n    super(adapter)\n    this[kAdapter] = adapter\n  }\n\n  /**\n   * @param  {Object} [options={}]\n   * @param  {boolean} [options.keepExistingData]\n   * @returns {Promise<FileSystemWritableFileStream>}\n   */\n  async createWritable (options = {}) {\n    return new FileSystemWritableFileStream(\n      await this[kAdapter].createWritable(options)\n    )\n  }\n\n  /**\n   * @returns {Promise<File>}\n   */\n  async getFile () {\n    return this[kAdapter].getFile()\n  }\n}\n\nObject.defineProperty(FileSystemFileHandle.prototype, Symbol.toStringTag, {\n  value: 'FileSystemFileHandle',\n  writable: false,\n  enumerable: false,\n  configurable: true\n})\n\nObject.defineProperties(FileSystemFileHandle.prototype, {\n  createWritable: { enumerable: true },\n  getFile: { enumerable: true }\n})\n\n// Safari doesn't support async createWritable streams yet.\nif (\n  globalThis.FileSystemFileHandle &&\n  !globalThis.FileSystemFileHandle.prototype.createWritable\n) {\n  const wm = new WeakMap()\n\n  let workerUrl\n\n  // Worker code that should be inlined (can't use any external functions)\n  const code = () => {\n    let fileHandle, handle\n\n    onmessage = async evt => {\n      const port = evt.ports[0]\n      const cmd = evt.data\n      switch (cmd.type) {\n        case 'open':\n          const file = cmd.name\n\n          let dir = await navigator.storage.getDirectory()\n\n          for (const folder of cmd.path) {\n            dir = await dir.getDirectoryHandle(folder)\n          }\n\n          fileHandle = await dir.getFileHandle(file)\n          handle = await fileHandle.createSyncAccessHandle()\n          break\n        case 'write':\n          handle.write(cmd.data, { at: cmd.position })\n          handle.flush()\n          break\n        case 'truncate':\n          handle.truncate(cmd.size)\n          break\n        case 'abort':\n        case 'close':\n          handle.close()\n          break\n      }\n\n      port.postMessage(0)\n    }\n  }\n\n\n  globalThis.FileSystemFileHandle.prototype.createWritable = async function (options) {\n    // Safari only support writing data in a worker with sync access handle.\n    if (!workerUrl) {\n      const stringCode = `(${code.toString()})()`\n      const blob = new Blob([stringCode], {\n        type: 'text/javascript'\n      })\n      workerUrl = URL.createObjectURL(blob)\n    }\n    const worker = new Worker(workerUrl, { type: 'module' })\n\n    let position = 0\n    const textEncoder = new TextEncoder()\n    let size = await this.getFile().then(file => file.size)\n\n    const send = message => new Promise((resolve, reject) => {\n      const mc = new MessageChannel()\n      mc.port1.onmessage = evt => {\n        if (evt.data instanceof Error) reject(evt.data)\n        else resolve(evt.data)\n        mc.port1.close()\n        mc.port2.close()\n        mc.port1.onmessage = null\n      }\n      worker.postMessage(message, [mc.port2])\n    })\n\n    // Safari also don't support transferable file system handles.\n    // So we need to pass the path to the worker. This is a bit hacky and ugly.\n    const root = await navigator.storage.getDirectory()\n    const parent = await wm.get(this)\n    const path = await root.resolve(parent)\n\n    // Should likely never happen, but just in case...\n    if (path === null) throw new DOMException(...GONE)\n\n    let controller\n    await send({ type: 'open', path, name: this.name })\n\n    if (options?.keepExistingData === false) {\n      await send({ type: 'truncate', size: 0 })\n      size = 0\n    }\n\n    const ws = new FileSystemWritableFileStream({\n      start: ctrl => {\n        controller = ctrl\n      },\n      async write(chunk) {\n        const isPlainObject = chunk?.constructor === Object\n\n        if (isPlainObject) {\n          chunk = { ...chunk }\n        } else {\n          chunk = { type: 'write', data: chunk, position }\n        }\n\n        if (chunk.type === 'write') {\n          if (!('data' in chunk)) {\n            await send({ type: 'close' })\n            throw new DOMException(...SYNTAX('write requires a data argument'))\n          }\n\n          chunk.position ??= position\n\n          if (typeof chunk.data === 'string') {\n            chunk.data = textEncoder.encode(chunk.data)\n          }\n\n          else if (chunk.data instanceof ArrayBuffer) {\n            chunk.data = new Uint8Array(chunk.data)\n          }\n\n          else if (!(chunk.data instanceof Uint8Array) && ArrayBuffer.isView(chunk.data)) {\n            chunk.data = new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.data.byteLength)\n          }\n\n          else if (!(chunk.data instanceof Uint8Array)) {\n            const ab = await new Response(chunk.data).arrayBuffer()\n            chunk.data = new Uint8Array(ab)\n          }\n\n          if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n            position = chunk.position\n          }\n          position += chunk.data.byteLength\n          size += chunk.data.byteLength\n        } else if (chunk.type === 'seek') {\n          if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n            if (size < chunk.position) {\n              throw new DOMException(...INVALID)\n            }\n            console.log('seeking', chunk)\n            position = chunk.position\n            return // Don't need to enqueue seek...\n          } else {\n            await send({ type: 'close' })\n            throw new DOMException(...SYNTAX('seek requires a position argument'))\n          }\n        } else if (chunk.type === 'truncate') {\n          if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n            size = chunk.size\n            if (position > size) { position = size }\n          } else {\n            await send({ type: 'close' })\n            throw new DOMException(...SYNTAX('truncate requires a size argument'))\n          }\n        }\n\n        await send(chunk)\n      },\n      async close () {\n        await send({ type: 'close' })\n        worker.terminate()\n      },\n      async abort (reason) {\n        await send({ type: 'abort', reason })\n        worker.terminate()\n      },\n    })\n\n    return ws\n  }\n\n  const orig = FileSystemDirectoryHandle.prototype.getFileHandle\n  FileSystemDirectoryHandle.prototype.getFileHandle = async function (...args) {\n    const handle = await orig.call(this, ...args)\n    wm.set(handle, this)\n    return handle\n  }\n}\n\nexport default FileSystemFileHandle\nexport { FileSystemFileHandle }\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","value","$bd841fffd4068e5b$export$db2751aad7d8e0f3","$bd841fffd4068e5b$export$2e2bcd8739ae039","$bAgeV","$gnYLk","INVALID","$bd841fffd4068e5b$var$INVALID","SYNTAX","$bd841fffd4068e5b$var$SYNTAX","GONE","$bd841fffd4068e5b$var$GONE","$jG9Jm","errors","$bd841fffd4068e5b$var$kAdapter","Symbol","default","constructor","adapter","createWritable","options","getFile","prototype","toStringTag","writable","defineProperties","FileSystemFileHandle","workerUrl","wm","WeakMap","code","fileHandle","handle","onmessage","evt","port","ports","cmd","data","type","file","name","dir","navigator","storage","getDirectory","folder","path","getDirectoryHandle","getFileHandle","createSyncAccessHandle","write","at","position","flush","truncate","size","close","postMessage","blob","Blob","toString","URL","createObjectURL","worker","Worker","textEncoder","TextEncoder","then","send","message","Promise","resolve","reject","mc","MessageChannel","port1","Error","port2","root","parent","DOMException","keepExistingData","start","ctrl","chunk","encode","ArrayBuffer","Uint8Array","isView","buffer","byteOffset","byteLength","ab","Response","arrayBuffer","Number","isInteger","console","log","terminate","abort","reason","orig","FileSystemDirectoryHandle","args","call"],"version":3,"file":"FileSystemFileHandle.f331cfd5.js.map"}